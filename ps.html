<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>手机适配透明图合成器</title>
<style>
  body { margin: 0; font-family: 'Segoe UI', sans-serif; background: #f0f2f5; display: flex; flex-direction: column; height: 100vh; }
  #toolbar { display: flex; flex-wrap: wrap; background: #fff; padding: 10px; box-shadow: 0 2px 6px rgba(0,0,0,0.1); }
  #toolbar input, #toolbar select, #toolbar button { margin: 5px; flex: 1 1 auto; padding: 6px 8px; font-size: 14px; border-radius: 4px; border: 1px solid #ccc; }
  #toolbar button { background: #4a90e2; color: white; border: none; }
  #container { flex: 1; position: relative; background: #fff; margin: 10px; border-radius: 8px; overflow: hidden; touch-action: none; }
  .item { position: absolute; cursor: grab; user-select: none; }
  #canvas { display: none; }
  label { font-size: 12px; margin-bottom: 2px; }
</style>
</head>
<body>

<div id="toolbar">
  <input type="file" id="fontInput" accept=".ttf">
  <input type="text" id="textInput" placeholder="输入文字">
  <input type="number" id="fontSize" value="40" min="10" max="200">
  <input type="color" id="fontColor" value="#000000">
  <button onclick="addText()">添加文字</button>
  <input type="file" id="imgInput" accept="image/*">
  <button onclick="addImage()">添加图片</button>
  <button onclick="exportImage()">导出PNG</button>
</div>

<div id="container"></div>
<canvas id="canvas" width="800" height="600"></canvas>

<script>
let currentFont = 'sans-serif';
document.getElementById('fontInput').addEventListener('change', function() {
    const file = this.files[0];
    if (!file) return;
    const fontName = 'customFont';
    const reader = new FileReader();
    reader.onload = function(e) {
        const fontData = e.target.result;
        const font = new FontFace(fontName, fontData);
        font.load().then(loadedFont => {
            document.fonts.add(loadedFont);
            currentFont = fontName;
            alert('字体加载完成，可使用该字体绘制文字');
        }).catch(err => console.error(err));
    };
    reader.readAsArrayBuffer(file);
});

const container = document.getElementById('container');

function makeTransformable(el) {
    el.style.left = '50px';
    el.style.top = '50px';
    el.style.transformOrigin = 'center center';
    el.style.transform = 'rotate(0deg) scale(1)';

    let lastX, lastY, startLeft, startTop, isDragging = false, scale = 1, angle = 0;

    function getTouch(e) { return e.touches[0] || e.changedTouches[0]; }

    el.addEventListener('touchstart', e => {
        if (e.touches.length === 1) {
            isDragging = true;
            const touch = getTouch(e);
            lastX = touch.clientX;
            lastY = touch.clientY;
            startLeft = parseFloat(el.style.left);
            startTop = parseFloat(el.style.top);
        } else if (e.touches.length === 2) {
            isDragging = false;
            // 保存初始缩放和角度
            el.initialDistance = getDistance(e);
            el.initialAngle = getAngle(e);
            el.startScale = scale;
            el.startAngle = angle;
        }
        e.preventDefault();
    });

    el.addEventListener('touchmove', e => {
        if (isDragging && e.touches.length === 1) {
            const touch = getTouch(e);
            const dx = touch.clientX - lastX;
            const dy = touch.clientY - lastY;
            el.style.left = startLeft + dx + 'px';
            el.style.top = startTop + dy + 'px';
        } else if (e.touches.length === 2) {
            const newDistance = getDistance(e);
            scale = el.startScale * (newDistance / el.initialDistance);

            const newAngle = getAngle(e);
            angle = el.startAngle + (newAngle - el.initialAngle);

            el.style.transform = `rotate(${angle}deg) scale(${scale})`;
        }
        e.preventDefault();
    });

    el.addEventListener('touchend', e => { if (e.touches.length === 0) isDragging = false; });

    function getDistance(e) {
        const [t1, t2] = e.touches;
        return Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
    }
    function getAngle(e) {
        const [t1, t2] = e.touches;
        return Math.atan2(t2.clientY - t1.clientY, t2.clientX - t1.clientX) * 180/Math.PI;
    }
}

function addText() {
    const text = document.getElementById('textInput').value;
    if (!text) return;
    const div = document.createElement('div');
    div.className = 'item';
    div.style.fontSize = document.getElementById('fontSize').value + 'px';
    div.style.color = document.getElementById('fontColor').value;
    div.style.fontFamily = currentFont;
    div.innerText = text;
    container.appendChild(div);
    makeTransformable(div);
}

function addImage() {
    const file = document.getElementById('imgInput').files[0];
    if (!file) return;
    const img = document.createElement('img');
    img.className = 'item';
    img.onload = () => container.appendChild(img);
    img.src = URL.createObjectURL(file);
    img.style.maxWidth = '300px';
    img.style.maxHeight = '300px';
    makeTransformable(img);
}

function exportImage() {
    const canvas = document.getElementById('canvas');
    canvas.width = container.clientWidth;
    canvas.height = container.clientHeight;
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const items = Array.from(container.children);
    const promises = [];

    items.forEach(el => {
        const left = parseFloat(el.style.left);
        const top = parseFloat(el.style.top);
        const transform = el.style.transform.match(/rotate\(([-\d.]+)deg\) scale\(([\d.]+)\)/);
        const angle = transform ? parseFloat(transform[1]) * Math.PI/180 : 0;
        const scale = transform ? parseFloat(transform[2]) : 1;

        ctx.save();
        ctx.translate(left + el.offsetWidth/2, top + el.offsetHeight/2);
        ctx.rotate(angle);
        ctx.scale(scale, scale);

        if (el.tagName === 'DIV') {
            ctx.font = `${el.style.fontSize} ${el.style.fontFamily}`;
            ctx.fillStyle = el.style.color || 'black';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(el.innerText, 0, 0);
        } else if (el.tagName === 'IMG') {
            promises.push(new Promise(resolve => {
                const img = new Image();
                img.onload = () => {
                    ctx.drawImage(img, -el.width/2, -el.height/2, el.width, el.height);
                    ctx.restore();
                    resolve();
                };
                img.src = el.src;
            }));
            return;
        }
        ctx.restore();
    });

    Promise.all(promises).then(() => {
        const dataURL = canvas.toDataURL('image/png');
        const a = document.createElement('a');
        a.href = dataURL;
        a.download = 'output.png';
        a.click();
    });
}
</script>

</body>
</html>
